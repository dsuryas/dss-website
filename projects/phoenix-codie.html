<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Phoenix Codie - Deepak Surya</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto+Mono:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Gabarito:wght@400..900&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
      rel="stylesheet"
    />
    <link href="https://fonts.cdnfonts.com/css/lexend" rel="stylesheet" />
    <link href="https://fonts.cdnfonts.com/css/satoshi" rel="stylesheet" />
    <link href="../styles.css" rel="stylesheet" />
    <!-- <style>
      /* Project Page Specific Styles */
      .project-container {
        display: flex;
        width: 80%;
        margin: 0 auto;
        padding: 2rem 0;
        min-height: 90vh;
      }

      .sidebar {
        flex: 0 0 20%;
        position: sticky;
        top: 2rem;
        height: calc(100vh - 4rem);
        overflow-y: auto;
        padding-right: 1.5rem;
      }

      .main-content {
        flex: 0 0 60%;
        overflow-y: auto;
        padding: 0 1.5rem;
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
      }

      .tech-sidebar {
        flex: 0 0 20%;
        position: sticky;
        top: 2rem;
        height: calc(100vh - 4rem);
        overflow-y: auto;
        padding-left: 1.5rem;
      }

      .toc-title,
      .tech-title {
        font-size: 1.2rem;
        font-weight: 600;
        margin-bottom: 1.5rem;
        color: var(--text-primary);
      }

      .toc-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      .toc-item {
        margin-bottom: 0.75rem;
      }

      .toc-link {
        display: block;
        padding: 0.5rem;
        color: var(--text-secondary);
        text-decoration: none;
        transition: all 0.2s ease;
        border-left: 2px solid transparent;
      }

      .toc-link:hover,
      .toc-link.active {
        color: var(--text-primary);
        border-left: 2px solid var(--accent);
        background-color: var(--hover-bg);
      }

      .toc-link.subheading {
        padding-left: 1.5rem;
        font-size: 0.9rem;
      }

      .project-header {
        margin-bottom: 2rem;
      }

      .project-title {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        line-height: 1.2;
      }

      .project-date {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin-bottom: 2rem;
      }

      .project-content {
        line-height: 1.8;
      }

      .project-content h2 {
        font-size: 1.8rem;
        margin: 2rem 0 1rem 0;
        color: var(--text-primary);
        padding-top: 1rem;
        scroll-margin-top: 2rem;
      }

      .project-content h3 {
        font-size: 1.4rem;
        margin: 1.5rem 0 1rem 0;
        color: var(--accent);
        scroll-margin-top: 2rem;
      }

      .project-content p {
        margin-bottom: 1.5rem;
        color: var(--text-secondary);
      }

      .project-content ul,
      .project-content ol {
        margin-bottom: 1.5rem;
        padding-left: 1.5rem;
        color: var(--text-secondary);
      }

      .project-content li {
        margin-bottom: 0.5rem;
      }

      .project-content img {
        max-width: 100%;
        margin: 2rem 0;
      }

      .project-content code {
        font-family: var(--font-mono);
        background-color: var(--card-bg);
        padding: 0.2rem 0.4rem;
        font-size: 0.9rem;
      }

      .project-content pre {
        background-color: var(--card-bg);
        padding: 1rem;
        overflow-x: auto;
        margin: 1.5rem 0;
      }

      .project-content pre code {
        background-color: transparent;
        padding: 0;
      }

      .back-link {
        display: inline-block;
        margin: 2rem 0;
        color: var(--accent);
        text-decoration: none;
        font-weight: 500;
      }

      .back-link:hover {
        text-decoration: underline;
      }

      .image-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 2rem 0;
      }

      .image-container img {
        max-width: 48%;
      }

      .arrow-icon {
        font-size: 2rem;
        color: var(--accent);
      }

      .highlight {
        color: var(--accent);
        font-weight: 500;
      }

      .code-block {
        font-family: var(--font-mono);
        font-size: 0.85rem;
        line-height: 1.5;
      }

      .tech-stack {
        margin-bottom: 2rem;
      }

      .tech-group {
        margin-bottom: 1.5rem;
      }

      .tech-group-title {
        font-size: 1rem;
        font-weight: 500;
        margin-bottom: 0.75rem;
        color: var(--text-primary);
      }

      .tech-item {
        display: block;
        background-color: var(--card-bg);
        color: var(--text-secondary);
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        font-size: 0.85rem;
        font-family: var(--font-mono);
      }

      .feature-block {
        background-color: var(--card-bg);
        padding: 1.5rem;
        margin: 1.5rem 0;
        border-left: 3px solid var(--accent);
      }

      .feature-block h4 {
        color: var(--text-primary);
        margin-bottom: 0.75rem;
        font-size: 1.2rem;
      }

      .feature-block p {
        margin-bottom: 0;
      }

      /* Theme toggle button styles */
      .global-theme-toggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        background-color: var(--card-bg);
        color: var(--text-primary);
        transition: background-color var(--transition-fast),
          color var(--transition-fast);
      }

      .global-theme-toggle:hover {
        background-color: var(--hover-bg);
      }

      /* Responsive styles */
      @media (max-width: 1200px) {
        .project-container {
          width: 95%;
        }
      }

      @media (max-width: 992px) {
        .project-container {
          flex-direction: column;
        }

        .sidebar,
        .tech-sidebar {
          position: static;
          height: auto;
          flex: 0 0 100%;
          margin-bottom: 2rem;
          padding: 0;
        }

        .main-content {
          flex: 0 0 100%;
          border-left: none;
          border-right: none;
          padding: 0;
        }

        .tech-sidebar {
          margin-top: 2rem;
          border-top: 1px solid var(--border);
          padding-top: 2rem;
        }
      }
    </style> -->
  </head>
  <body class="noir-filter">
    <!-- Spotlight/Torch Effect -->
    <div class="spotlight" id="spotlight"></div>
    <div class="cursor" id="cursor"></div>

    <!-- Global Theme Toggle -->
    <button
      class="global-theme-toggle"
      id="global-theme-toggle"
      aria-label="Toggle dark/light mode"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
    </button>

    <div class="project-container">
      <!-- Left Sidebar with TOC -->
      <aside class="sidebar">
        <h3 class="toc-title">Table of Contents</h3>
        <ul class="toc-list">
          <li class="toc-item">
            <a href="#project-overview" class="toc-link">Project Overview</a>
          </li>
          <li class="toc-item">
            <a href="#the-big-problem" class="toc-link">The Big Problem</a>
          </li>
          <li class="toc-item">
            <a href="#key-features" class="toc-link">Key Features</a>
          </li>
          <li class="toc-item">
            <a href="#the-plan" class="toc-link"
              >The Plan: Smarter, Not Harder</a
            >
          </li>
          <li class="toc-item">
            <a href="#alchemist-engine" class="toc-link"
              >The Alchemist Engine</a
            >
          </li>
          <li class="toc-item">
            <a href="#layout-detection" class="toc-link subheading"
              >Layout Pattern Detection</a
            >
          </li>
          <li class="toc-item">
            <a href="#layout-extractor" class="toc-link subheading"
              >Layout Extractor</a
            >
          </li>
          <li class="toc-item">
            <a href="#position-detection" class="toc-link subheading"
              >Position Detection</a
            >
          </li>
          <li class="toc-item">
            <a href="#results-impact" class="toc-link">Results & Impact</a>
          </li>
          <li class="toc-item">
            <a href="#component-identification" class="toc-link"
              >Smart Component Identification</a
            >
          </li>
          <li class="toc-item">
            <a href="#lessons" class="toc-link">Lessons From the Grind</a>
          </li>
          <li class="toc-item">
            <a href="#layouts-tricky" class="toc-link subheading"
              >Layouts Are Tricky</a
            >
          </li>
          <li class="toc-item">
            <a href="#nested-components" class="toc-link subheading"
              >Nested Components = Chaos</a
            >
          </li>
          <li class="toc-item">
            <a href="#error-handling" class="toc-link subheading"
              >Error Handling Saves Lives</a
            >
          </li>
          <li class="toc-item">
            <a href="#documentation" class="toc-link subheading"
              >Documentation Importance</a
            >
          </li>
          <li class="toc-item">
            <a href="#design-patterns" class="toc-link">Design Patterns Used</a>
          </li>
          <li class="toc-item">
            <a href="#business-value" class="toc-link"
              >Business Value & Conclusion</a
            >
          </li>
          <li class="toc-item">
            <a href="#future-enhancements" class="toc-link"
              >Future Enhancements</a
            >
          </li>
        </ul>
      </aside>

      <!-- Main Content Area -->
      <main class="main-content">
        <div class="project-header">
          <h1 class="project-title">
            Phoenix Codie: Figma-to-React Code Generator
          </h1>
          <p class="project-date">March 15, 2023</p>
        </div>

        <div class="project-content">
          <h2 id="project-overview">Project Overview</h2>
          <p>
            Phoenix Codie is a sophisticated tool that automates the conversion
            of Figma designs into production-ready React code. It serves as a
            bridge between designers and developers, significantly reducing the
            time and effort required to transform design mockups into functional
            components.
          </p>

          <img
            src="https://via.placeholder.com/800x400"
            alt="Phoenix Codie Interface"
          />

          <p>
            Every product team knows the struggle: you've crafted a drop-dead
            gorgeous component in Figma, but then reality hits and you realise
            that turning it into actual code is like assembling IKEA furniture
            without a manual. Hours vanish, your sanity takes a hit, and
            somehow, your beautiful design looks like it lost a fight with CSS.
            And don't even get me started on naming variables—because somehow,
            <code>containerDivFinal_Final2</code> always sneaks in. This gap
            between design and development has been a major speed bump in
            shipping polished products efficiently.
          </p>

          <p>
            Enter Phoenix Codie - the solution to this chaos. It accepts Figma
            URLs or file keys, extracts design structure through the Figma API,
            and generates corresponding React components with matching styles.
            No "why is this misaligned?" breakdowns, no extra drama - just
            clean, production-ready code that actually works.
          </p>

          <p>
            Let me spill some tea on how I built it, the "fun" (<em
              >read: rage-inducing</em
            >) roadblocks I hit, and the facepalms I collected along the way. If
            you're a dev, a designer, or just curious about this cool tech
            mashup, buckle up, this is gonna be a ride!
          </p>

          <h2 id="the-big-problem">The Big Problem</h2>
          <p>
            So, here's the tea: converting Figma designs into code is slow and
            frustrating. It's not as fun as debugging a production issue on a
            Friday night. Developers spend hours figuring out:
          </p>
          <ul>
            <li>
              How to translate Figma layouts into CSS without summoning the dark
              forces of <code>!important</code>.
            </li>
            <li>Which props to use and where.</li>
            <li>
              Keeping components reusable and design-system-approved (because
              future you will 100% judge past you).
            </li>
          </ul>

          <p>
            And let's be honest—most design-to-code tools give you meh output.
            You get some messy HTML/CSS that feels outdated, like it's stuck in
            2010. No React vibes, no reusable components, and definitely no love
            for design systems.
          </p>

          <h2 id="key-features">Key Features</h2>

          <div class="feature-block">
            <h4>Design-to-Code Conversion</h4>
            <p>
              Phoenix Codie accepts Figma file URLs or file keys, intelligently
              identifies components from Figma designs, detects layout patterns,
              and accurately extracts styling properties.
            </p>
          </div>

          <div class="feature-block">
            <h4>User Interface</h4>
            <p>
              Features a split-panel view with generated React markup and
              styles, real-time preview of components, version history tracking,
              and support for both dark and light modes.
            </p>
          </div>

          <div class="feature-block">
            <h4>Code Enhancement</h4>
            <p>
              Includes an AI-assisted chat interface for refinement, supports
              direct download of generated code, offers framework conversion
              capabilities, and provides tools for integrating API endpoints or
              JSON data.
            </p>
          </div>

          <h2 id="the-plan">The Plan: Smarter, Not Harder</h2>
          <p>
            We wanted Phoenix Codie to be a specialist, not just another
            half-baked, "look-ma-I-exported-HTML" tool. Phoenix Codie employs a
            client-server architecture with several specialized subsystems:
          </p>

          <img
            src="https://via.placeholder.com/800x400"
            alt="Phoenix Codie Architecture"
          />

          <p>
            The plan involved building a sophisticated system with these key
            components:
          </p>

          <ol>
            <li>
              <strong>Client Application:</strong> React-based frontend for user
              interaction and code display
            </li>
            <li>
              <strong>API Server:</strong> Express.js backend that communicates
              with the Figma API
            </li>
            <li>
              <strong>Parsing Engine:</strong> System to transform Figma API
              responses into an intermediate representation
            </li>
            <li>
              <strong>Code Generation System:</strong> Converts the intermediate
              representation into React components
            </li>
            <li>
              <strong>LLM Service:</strong> Handles AI-assisted code refinement
              through a chat interface
            </li>
          </ol>

          <p>The typical data flow works like this:</p>

          <ol>
            <li>User inputs a Figma URL through the web interface</li>
            <li>Server extracts the file key and node ID from the URL</li>
            <li>
              Server requests design data from the Figma API using
              authentication tokens
            </li>
            <li>Design data is processed through the parsing engine</li>
            <li>
              Component structures and styles are extracted and mapped to React
              equivalents
            </li>
            <li>
              Generated code is sent back to the client for display and preview
            </li>
            <li>
              User can refine the code via direct editing or AI assistance
            </li>
            <li>Final code can be downloaded or saved for later use</li>
          </ol>

          <h2 id="alchemist-engine">The Alchemist Engine - The Execution</h2>
          <p>
            The heart of Phoenix Codie lies in its Alchemist engine — a
            sophisticated system for analyzing and transforming Figma designs
            into React components. Let me give you the lowdown on how this
            powerhouse runs the show.
          </p>

          <h3 id="layout-detection">1. Layout Pattern Detection System</h3>
          <img
            src="https://via.placeholder.com/800x500"
            alt="Layout Pattern Detection System Diagram"
          />

          <p>
            When a developer looks at a design—let's say a grid layout—they'd
            visually identify the elements and think, "Ok, these elements are
            aligned both horizontally and vertically with consistent spacing -
            this is clearly a grid layout." It's similar to how we instinctively
            recognize a spreadsheet pattern.
          </p>

          <p>
            First, I wanted to spot how the elements are arranged. When elements
            are positioned in the design, check their coordinates and grouping.
            For example:
          </p>

          <pre class="code-block">
Element 1: (x: 0, y: 0)
Element 2: (x: 200, y: 0)
Element 3: (x: 400, y: 0)
Element 4: (x: 0, y: 200)
Element 5: (x: 200, y: 200)
Element 6: (x: 400, y: 200)
</pre
          >

          <p>
            If elements share the same x-coordinate (or close enough) and have
            consistent spacing on the y-axis - it's a vertical stack. Flip it,
            reverse it, do a little dance, and boom—you've now got a horizontal
            stack. Easy, right?
          </p>

          <p>But then… then comes the dark side. The GAPS.</p>

          <p>
            After a few "maybe I should quit and become a goat farmer" moments,
            I got some sage advice, got myself a ruler and got to work.
          </p>

          <p>I used the x and y coordinates and the size of the elements to:</p>
          <ul>
            <li>Measure gaps between elements</li>
            <li>Identify consistent spacing patterns</li>
            <li>Convert absolute spacing to relative units</li>
          </ul>

          <h3 id="layout-extractor">2. Layout Extractor</h3>
          <p>
            Once the layout pattern is identified, it's time to apply the layout
            properties with respect to itself and the parent-child and sibling
            relationships.
          </p>

          <p>
            The main goals are to get and standardize basic layout properties,
            deal with auto-layout conversion, handle padding and spacing
            precisely, and make the resulting layout structure as good as
            possible.
          </p>

          <p>To go about this, we'll need:</p>
          <ul>
            <li>The element's exact position (x, y coordinates)</li>
            <li>Its dimensions (width and height)</li>
            <li>How it relates to its parent container, and</li>
            <li>
              Whether it uses Figma's auto-layout (it's Figma's way of saying
              'flexbox')
            </li>
          </ul>

          <p>
            When Figma says "this is an auto-layout container" it means it's a
            flexbox. I made a mapping system that goes like this:
          </p>
          <ul>
            <li>HORIZONTAL layout → flex-direction: row</li>
            <li>VERTICAL layout → flex-direction: column</li>
            <li>primaryAxisAlignItems → justify-content</li>
            <li>counterAxisAlignItems → align-items</li>
          </ul>

          <h3 id="position-detection">3. Position Detection System</h3>
          <p>
            The Position Detection System is the brains behind perfect element
            placement. Here's how it works:
          </p>
          <ul>
            <li>
              Scans positions → Checks where elements sit in relation to each
              other
            </li>
            <li>Spots alignment patterns → Detects if things are lined up</li>
            <li>Assigns CSS positioning → No more position: absolute abuse</li>
            <li>Handles edge cases → Overlaps and nested elements</li>
          </ul>

          <p>
            It's basically the GPS for the UI elements—mapping out their
            placement like a 3D coordinate system but for web layouts.
          </p>

          <h2 id="results-impact">The Glow-Up: Results & Impact</h2>
          <p>
            With Phoenix Codie, what used to take hours now takes minutes. Some
            quick stats:
          </p>
          <ul>
            <li>
              <span class="highlight">70% faster</span> component
              implementation.
            </li>
            <li>
              Clean, high-quality React code that actually follows design-system
              rules.
            </li>
            <li>Less need for reworks.</li>
          </ul>

          <p>
            Developers who've tried it are like, "Where has this been all my
            life?"
          </p>

          <p>
            Alright, Let's talk numbers—because nothing says "trust me, bro"
            like cold, hard stats. Old-school vs. Phoenix Codie.
          </p>

          <p>
            <strong>Aspero Desktop:</strong>
          </p>
          <ul>
            <li>Regular approach: 8 - 9 hours</li>
            <li>Phoenix Codie: 2 - 3 hours</li>
          </ul>

          <p>
            <strong>Aspero Mobile:</strong>
          </p>
          <ul>
            <li>Regular approach: 8 - 9 hours</li>
            <li>Phoenix Codie: 2 - 3 hours</li>
          </ul>

          <div class="image-container">
            <img
              src="https://via.placeholder.com/350x500"
              alt="Original design"
            />
            <span class="arrow-icon">→</span>
            <img
              src="https://via.placeholder.com/350x500"
              alt="Generated output"
            />
          </div>

          <p>
            <strong>Acumen:</strong>
          </p>
          <ul>
            <li>
              Regular approach:
              <ul>
                <li>Existing setup - 7 to 8 hrs</li>
                <li>New setup - 14 to 16 hrs</li>
              </ul>
            </li>
            <li>Phoenix Codie: 2 - 3 hours</li>
          </ul>

          <p>TL;DR—Codie takes dev time from "ugh" to "done" in no time.</p>

          <h2 id="component-identification">Smart Component Identification</h2>
          <p>
            One of the most impressive features is how Phoenix Codie
            intelligently maps Figma components to appropriate React components:
          </p>

          <pre class="code-block">
function identifyComponentType(node) {
  // Special case for icons
  if (node.name?.toLowerCase().includes('icon')) {
    return 'Icon';
  }

  // Special case for tables
  if (node.name?.toLowerCase().includes('table v3')) {
    return 'Table';
  }

  // Handle instance components
  if (node.type === 'INSTANCE') {
    const trimmedName = node.name.split(/[^a-zA-Z0-9 ]/)[0];
    const matchedComponent = Object.keys(componentTypeMap).find((key) => 
      trimmedName?.toLowerCase().includes(key.toLowerCase())
    );
    
    if (matchedComponent) {
      return componentTypeMap[matchedComponent];
    }
  }

  // Handle text nodes
  if (node.type === 'TEXT') {
    return 'Typography';
  }

  // Default case
  return 'View';
}</pre
          >

          <div class="image-container">
            <img
              src="https://via.placeholder.com/350x350"
              alt="Original nested components"
            />
            <span class="arrow-icon">→</span>
            <img
              src="https://via.placeholder.com/350x350"
              alt="Generated component hierarchy"
            />
          </div>

          <h2 id="lessons">Lessons From the Grind</h2>
          <p>
            Building Phoenix Codie was like trying to assemble a jigsaw puzzle
            where half the pieces are invisible and the other half explode on
            contact. Converting Figma's positioning madness into sleek,
            maintainable Flexbox and Grid layouts was the biggest challenge. At
            this point, I don't even code—I just perform dark rituals and hope
            the CSS gods grant me mercy.
          </p>

          <h3 id="layouts-tricky">1. Layouts Are Tricky</h3>
          <p>
            Figma uses absolute positioning but React leans on Flexbox/Grid.
            They don't exactly shake hands. Translation is <em>Hard</em>. Guess
            who had to play translator? Yeah.
          </p>

          <p>
            Figma's auto-layout system, while powerful, doesn't map perfectly to
            CSS Flexbox and Grid.
          </p>
          <ol>
            <li>
              Spacing Inconsistencies: Figma's spacing model needed careful
              translation to CSS
            </li>
            <li>
              Nested Auto-layouts: Complex nested layouts required special
              handling
            </li>
            <li>
              Responsive Considerations: Making the generated code responsive
              while maintaining design fidelity
            </li>
          </ol>

          <h3 id="nested-components">2. Nested Components = Chaos</h3>
          <p>
            One of the biggest surprises was the complexity of handling nested
            components. What seemed straightforward in theory became complex
            when dealing with real-world designs. A button, for instance. It has
            hover states, focus styles, active states, disabled versions, and a
            hidden variant for some reason. Codie handles this gracefully by
            breaking down each layer into props.
          </p>

          <h3 id="error-handling">3. Error Handling Saves Lives</h3>
          <p>
            Early versions of Codie simply failed on invalid inputs. One wrong
            move, and the whole thing went down. But we leveled up.
          </p>
          <ol>
            <li>
              Graceful Degradation: When certain properties couldn't be
              extracted, the system falls back to sensible defaults.
            </li>
            <li>
              Detailed Error Reporting: Instead of vague "something broke"
              messages, you actually get useful info.
            </li>
            <li>
              Recovery Mechanisms: The ability to continue processing even when
              parts of the design are invalid.
            </li>
          </ol>

          <h3 id="documentation">4. Documentation Importance</h3>
          <p>
            You know what's fun? Building cool stuff. You know what's not fun?
            Trying to remember how that cool stuff works six months later.
          </p>

          <p>That's why we created detailed docs for:</p>
          <ol>
            <li>Component mappings</li>
            <li>Property translations</li>
            <li>Style conversions</li>
            <li>Common error scenarios</li>
          </ol>

          <p>
            This documentation proved invaluable. Because Telepathy Isn't a
            Feature (Yet).
          </p>

          <p>
            The most valuable lesson was the importance of real-world testing
            with actual design files, as they often contained edge cases that
            weren't covered by our initial test suite. There were a lot of
            "well, that's new" moments.
          </p>

          <h2 id="design-patterns">Design Patterns Used</h2>
          <p>
            Building Phoenix Codie required implementing several sophisticated
            design patterns:
          </p>

          <div class="feature-block">
            <h4>Extractor Factory Pattern</h4>
            <p>
              Allows for specialized handling of different component types while
              maintaining a consistent interface:
            </p>
          </div>

          <pre class="code-block">
class ComponentPropExtractorFactory {
  static extractorMap = {
    Button: ButtonPropExtractor,
    Tabs: TabsPropExtractor,
    // ... other extractors
  };

  static create(node, componentType, componentDoc, parentLayout, propMapping) {
    const ExtractorClass = this.extractorMap[componentType] || GenericComponentPropExtractor;
    return new ExtractorClass(node, componentType, componentDoc, parentLayout, propMapping);
  }
}</pre
          >

          <div class="feature-block">
            <h4>Composite Pattern</h4>
            <p>Represents the hierarchical structure of UI components:</p>
          </div>

          <pre class="code-block">
createContainerComponent(node, layout, styles, children, depth, figmaImages) {
  let childComponents = children.map((child) => 
    this.traverse(child, layout, depth + 1, figmaImages)
  ).filter(Boolean);
  
  return {
    type: node.type === "FRAME" ? "View" : "Group",
    key: node.id,
    name: node.name,
    layout,
    style: styles,
    children: childComponents,
    spacing: this.extractSpacingInfo(node),
  };
}</pre
          >

          <p>
            These patterns and approaches have been crucial in shaping Phoenix
            Codie into a more robust and reliable tool. Each challenge we
            encountered led to improvements in the system's architecture and
            capabilities, making it better suited for real-world use cases.
          </p>

          <p>
            TL;DR – Docs matter. Testing matters. And design patterns are your
            friends.
          </p>

          <img
            src="https://via.placeholder.com/800x400"
            alt="Phoenix Codie complete workflow diagram"
          />

          <h2 id="business-value">Business Value & Conclusion</h2>
          <p>
            Phoenix Codie provides significant value in the
            design-to-development workflow:
          </p>

          <ol>
            <li>
              <strong>Time Savings:</strong> Reduces the time required to
              translate designs into code by 60-80%
            </li>
            <li>
              <strong>Consistency:</strong> Ensures consistent implementation of
              design elements across applications
            </li>
            <li>
              <strong>Quality:</strong> Generates optimized, clean code that
              follows best practices
            </li>
            <li>
              <strong>Collaboration:</strong> Improves designer-developer
              collaboration by providing a common reference point
            </li>
            <li>
              <strong>Iteration Speed:</strong> Enables rapid design iteration
              by quickly reflecting changes in code
            </li>
          </ol>

          <p>
            Phoenix Codie represents a sophisticated solution to the persistent
            challenge of translating designs into code. We took the design-dev
            handshake, slapped some AI into it, and made the whole process
            ridiculously smooth. No more nightmares, no more therapy sessions.
            Just clean, fast, and design-accurate code that makes devs and
            designers finally get along (well, mostly).
          </p>

          <p>
            The system's architecture demonstrates a thoughtful approach to the
            problem, with specialized modules handling different aspects of the
            conversion process and a user-friendly interface that makes the tool
            accessible to both developers and designers. The integration of AI
            assistance further enhances its capabilities, allowing for natural
            language refinement of the generated code.
          </p>

          <h2 id="future-enhancements">Future Enhancements</h2>
          <p>Potential areas for expansion of Phoenix Codie include:</p>

          <ul>
            <li>
              Animation Support: Detecting and implementing animations from
              Figma designs
            </li>
            <li>
              Design System Integration: Direct mapping to established component
              libraries
            </li>
            <li>
              Code Export Formats: Support for additional frameworks beyond
              React
            </li>
            <li>
              Custom Component Creation: Adding custom component templates
            </li>
            <li>
              Design Validation: Checking designs for implementation feasibility
            </li>
            <li>
              Accessibility Review: Suggestions for improving accessibility in
              generated code
            </li>
          </ul>

          <p>
            As design systems and component-based development continue to grow
            in importance, tools like Phoenix Codie will play an increasingly
            vital role in streamlining the development process, enabling teams
            to focus on innovation rather than implementation details.
          </p>

          <p>Got feature requests? Drop 'em hot—we're always listening.</p>

          <p>
            Codie streamlines workflows, keeps code clean, and ensures that what
            you design is what you ship. The only question is: Are you in?
          </p>
        </div>
      </main>

      <!-- Right Sidebar with Tech Stack -->
      <aside class="tech-sidebar">
        <h3 class="tech-title">Tech Stack</h3>

        <div class="tech-stack">
          <div class="tech-group">
            <h4 class="tech-group-title">Frontend</h4>
            <span class="tech-item">React</span>
            <span class="tech-item">Tailwind CSS</span>
            <span class="tech-item">Prism.js</span>
            <span class="tech-item">React Live</span>
          </div>

          <div class="tech-group">
            <h4 class="tech-group-title">Backend</h4>
            <span class="tech-item">Express.js</span>
            <span class="tech-item">Axios</span>
            <span class="tech-item">Figma API</span>
          </div>

          <div class="tech-group">
            <h4 class="tech-group-title">AI Integration</h4>
            <span class="tech-item">LLM Service</span>
            <span class="tech-item">Natural Language Processing</span>
          </div>

          <div class="tech-group">
            <h4 class="tech-group-title">Development Tools</h4>
            <span class="tech-item">Webpack</span>
            <span class="tech-item">Babel</span>
            <span class="tech-item">ESLint & Prettier</span>
            <span class="tech-item">Nodemon</span>
          </div>
        </div>
      </aside>
    </div>

    <script src="../script.js"></script>
  </body>
</html>
